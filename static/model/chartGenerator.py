"""
StockGenerator_Backend.ipynb

Automatically generated by Colaboratory.
"""

import os
import pandas as pd
import numpy as np
import datetime
import random
import csv
from tensorflow.keras.layers import Dense, InputLayer, LSTM, TimeDistributed
from tensorflow.keras.models import Sequential, load_model
from sklearn.preprocessing import MinMaxScaler

latent_dim = 120
window_size = 60

dir = 'static/model/'

def getModel():
  model = Sequential()
  model.add(InputLayer(input_shape=(window_size, 1)))
  model.add(LSTM(latent_dim, return_sequences=True))
  model.add(LSTM(latent_dim, return_sequences=True))
  model.add(LSTM(latent_dim, return_sequences=True))
  model.add(TimeDistributed(Dense(1, activation='relu')))

  model.load_weights(dir + 'weight.hdf5')

  mms_data = [[1.9837562915454279], [12.516805739997075]]
  mms = MinMaxScaler().fit(mms_data)

  return model, mms

def preprocessing(data, mms):
  data = np.log(data)
  data = mms.transform(data.reshape(-1, 1))
  return data

def postprocessing(data, mms):
  data = data.reshape(-1, 1)
  data = mms.inverse_transform(data)
  data = np.exp(data)
  return data

def applyCapRule(new_data, old_data, mms):
  if old_data == -1:
    return new_data

  new_denorm = postprocessing(np.array([new_data]), mms)[0]
  old_denorm = postprocessing(np.array([old_data]), mms)[0]

  hi_cap = 1.15 * old_denorm
  lo_cap = 0.97 * old_denorm

  if new_denorm > hi_cap:
    new_denorm = hi_cap
  if new_denorm < lo_cap:
    new_denorm = lo_cap

  ret = preprocessing(np.array([new_denorm]), mms)[0]
  return ret


def generate(model, seed, length, mms):
  generated = [data[0] for data in seed[0]]
  yesterday = -1
  for i in range(length):
    new_generated = model.predict(seed)[0][-1][0]
    new_generated = applyCapRule(new_generated, yesterday, mms)
    generated.append(new_generated)
    for j in range(window_size-1):
      seed[0][j] = seed[0][j+1]
    seed[0][window_size-1] = [new_generated]
    yesterday = new_generated
  generated = np.array(generated)
  generated = postprocessing(generated, mms)
  return generated

def generateOpenClose(model_opcl, seed, length, mms):
  seed_opcl = np.array([[data for data in seed]]).reshape(1, 60, 1)
  generated_opcl = generate(model_opcl, seed_opcl, 2*length, mms)

  generated_op = []
  generated_cl = []

  for i in range(len(generated_opcl)):
    if i%2 == 0:
      generated_op.append(generated_opcl[i])
    else:
      generated_cl.append(generated_opcl[i])

  generated_op = np.array(generated_op)
  generated_cl = np.array(generated_cl)

  return generated_op, generated_cl

def generateLowHigh(generated_op, generated_cl):
  generated_lo = []
  generated_hi = []
  open = True
  yesterday = -1
  for op, cl in zip(generated_op, generated_cl):
    lo = min(op, cl)
    hi = max(op, cl)

    if yesterday != -1:
      hi_cap = 1.25 * yesterday
      lo_cap = 0.93 * yesterday
      generated_lo.append(random.uniform(max(lo * 0.93, lo_cap), lo))
      generated_hi.append(random.uniform(hi, min(hi * 1.05, hi_cap)))
    else:
      generated_lo.append(lo)
      generated_hi.append(hi)
    if not open:
      yesterday = cl
    open = not open

  generated_lo = np.array(generated_lo)
  generated_hi = np.array(generated_hi)

  return generated_lo, generated_hi

def generateDate(length):
  start_date = datetime.date.today()
  ret = [start_date + datetime.timedelta(days=d) for d in range(-(window_size // 2), length)]
  ret = [data.strftime("%Y-%m-%d") for data in ret]
  return ret

def getInit(seed_number):
  with open(dir + 'init.csv') as csv_file:
    reader = csv.reader(csv_file)
    row = list(reader)[seed_number]
    return [np.array([float(x) for x in row])]

def generateOLHC(seed, length):  #seed = 0-198854, don't set length too big
  model, mms = getModel()
  input_data = getInit(seed)
  generated_op, generated_cl = generateOpenClose(model, input_data, length, mms)
  generated_op = np.multiply(generated_op, 50/7.27)
  generated_cl = np.multiply(generated_cl, 50/7.27)
  generated_lo, generated_hi = generateLowHigh(generated_op, generated_cl)
  generated_dt = generateDate(length)

  df_generated = pd.DataFrame()
  df_generated['Date'] = generated_dt
  df_generated['Open'] = generated_op
  df_generated['Low'] = generated_lo
  df_generated['High'] = generated_hi
  df_generated['Close'] = generated_cl

  ret = []
  for index, row in df_generated.iterrows():
    tmp = {
        'time': row['Date'],
        'open': int(row['Open']),
        'high' : int(row['High']),
        'low' : int(row['Low']),
        'close' : int(row['Close'])
    }
    ret.append(tmp)
  return ret

def generateStockPrice(days, seed):
    f = open (dir + "stock-chart-data.js", "w")
    gen = generateOLHC(seed, 100)
    initial_chart, generated_chart = gen[30:(days+30)], gen[(days+30):]

    f.write("var stockChartData_i = [")
    start = True;
    for days in initial_chart:
        if (start == False):
            f.write(", ")
        start = False

        f.write(f"{{ time: '{days['time']}', open: {days['open']}, high: {days['high']}, low: {days['low']}, close: {days['close']} }}")
    f.write("]")

    f.write('\n')
    f.write('\n')

    f.write("var stockChartData_g = [")
    start = True;
    for days in generated_chart:
        if (start == False):
            f.write(", ")
        start = False

        f.write(f"{{ time: '{days['time']}', open: {days['open']}, high: {days['high']}, low: {days['low']}, close: {days['close']} }}")
    f.write("]")

    f.close()

# """#Testing Only"""
#
# generate = generateOLHC(2, 60)
# print(generate)
#
# import plotly.graph_objects as go
#
# fig = go.Figure(data=[go.Candlestick(x = generate['Date'],
#                                      open = generate['Open'],
#                                      close = generate['Close'],
#                                      low = generate['Low'],
#                                      high = generate['High']
# )])
#
# fig.update_layout(xaxis_rangeslider_visible=False)
# fig.show()
